// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./VerifiedWrappedSOS.sol";

contract VerifiedWrappedSOSFactory {

    event WrappedSOSDeployed(
        address indexed wrapper,
        address indexed sos,
        bytes32 salt
    );

    /**
     * @notice Deploy a new Verified WrappedSOS via CREATE2
     * @param name Name of the wrapped token
     * @param symbol Symbol
     * @param sosAddress SOS contract to wrap
     * @param emergencyFreeze Optional freeze flag
     * @param expectedCodeHash Optional SOS bytecode hash enforcement (0 = no enforcement)
     * @param expectedLineageHash Optional lineage hash enforcement (0 = no enforcement)
     * @param salt CREATE2 salt
     */
    function deployVerifiedWrappedSOS(
        string memory name,
        string memory symbol,
        address sosAddress,
        bool emergencyFreeze,
        bytes32 expectedCodeHash,
        bytes32 expectedLineageHash,
        bytes32 salt
    ) external returns (address wrapper) {
        bytes memory bytecode = abi.encodePacked(
            type(VerifiedWrappedSOS).creationCode,
            abi.encode(
                name,
                symbol,
                sosAddress,
                emergencyFreeze,
                expectedCodeHash,
                expectedLineageHash
            )
        );

        assembly {
            wrapper := create2(
                0,                // no ETH
                add(bytecode, 0x20),
                mload(bytecode),
                salt
            )
            if iszero(wrapper) { revert(0, 0) }
        }

        emit WrappedSOSDeployed(wrapper, sosAddress, salt);
    }

    /**
     * @notice Compute the deterministic address for a WrappedSOS before deployment
     */
    function computeAddress(
        bytes32 salt,
        address deployer,
        string memory name,
        string memory symbol,
        address sosAddress,
        bool emergencyFreeze,
        bytes32 expectedCodeHash,
        bytes32 expectedLineageHash
    ) external pure returns (address predicted) {
        bytes memory bytecode = abi.encodePacked(
            type(VerifiedWrappedSOS).creationCode,
            abi.encode(
                name,
                symbol,
                sosAddress,
                emergencyFreeze,
                expectedCodeHash,
                expectedLineageHash
            )
        );

        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff),
                deployer,
                salt,
                keccak256(bytecode)
            )
        );

        predicted = address(uint160(uint256(hash)));
    }
}
