// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface ISOS {
    function balanceOf(address) external view returns (uint256);
    function lineageHash() external view returns (bytes32);
}

contract VerifiedWrappedSOSFactory {

    event WrappedSOSDeployed(
        address indexed wrapper,
        address indexed sos,
        bytes32 salt
    );

    /**
     * @notice Deploy a new Verified WrappedSOS via CREATE2
     * @param name Name of the wrapped token
     * @param symbol Symbol
     * @param sosAddress SOS contract to wrap
     * @param emergencyFreeze Optional freeze flag
     * @param expectedCodeHash Optional SOS bytecode hash enforcement (0 = no enforcement)
     * @param expectedLineageHash Optional lineage hash enforcement (0 = no enforcement)
     * @param salt CREATE2 salt
     */
    function deployVerifiedWrappedSOS(
        string memory name,
        string memory symbol,
        address sosAddress,
        bool emergencyFreeze,
        bytes32 expectedCodeHash,
        bytes32 expectedLineageHash,
        bytes32 salt
    ) external returns (address wrapper) {
        bytes memory bytecode = abi.encodePacked(
            type(VerifiedWrappedSOS).creationCode,
            abi.encode(name, symbol, sosAddress, emergencyFreeze, expectedCodeHash, expectedLineageHash)
        );

        assembly {
            wrapper := create2(0, add(bytecode, 0x20), mload(bytecode), salt)
            if iszero(wrapper) { revert(0, 0) }
        }

        emit WrappedSOSDeployed(wrapper, sosAddress, salt);
    }

    /**
     * @notice Compute the deterministic address for a WrappedSOS before deployment
     */
    function computeAddress(
        bytes32 salt,
        address deployer,
        string memory name,
        string memory symbol,
        address sosAddress,
        bool emergencyFreeze,
        bytes32 expectedCodeHash,
        bytes32 expectedLineageHash
    ) external pure returns (address predicted) {
        bytes memory bytecode = abi.encodePacked(
            type(VerifiedWrappedSOS).creationCode,
            abi.encode(name, symbol, sosAddress, emergencyFreeze, expectedCodeHash, expectedLineageHash)
        );
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff),
                deployer,
                salt,
                keccak256(bytecode)
            )
        );
        predicted = address(uint160(uint256(hash)));
    }
}

contract VerifiedWrappedSOS {

    string public name;
    string public symbol;
    uint8 public constant decimals = 18;

    ISOS public immutable sos;
    bool public immutable emergencyFreeze;

    bytes32 public immutable expectedCodeHash;
    bytes32 public immutable expectedLineageHash;

    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor(
        string memory name_,
        string memory symbol_,
        address sosAddress_,
        bool emergencyFreeze_,
        bytes32 expectedCodeHash_,
        bytes32 expectedLineageHash_
    ) {
        require(sosAddress_ != address(0), "SOS zero address");

        name = name_;
        symbol = symbol_;
        sos = ISOS(sosAddress_);
        emergencyFreeze = emergencyFreeze_;
        expectedCodeHash = expectedCodeHash_;
        expectedLineageHash = expectedLineageHash_;

        // Optional code hash enforcement
        if (expectedCodeHash_ != bytes32(0)) {
            require(
                keccak256(abi.encodePacked(address(sos).code)) == expectedCodeHash_,
                "SOS code hash mismatch"
            );
        }

        // Optional lineage hash enforcement
        if (expectedLineageHash_ != bytes32(0)) {
            try sos.lineageHash() returns (bytes32 h) {
                require(h == expectedLineageHash_, "SOS lineage mismatch");
            } catch {
                revert("Failed to read SOS lineage");
            }
        }
    }

    // ============ WRAPPED MINT ============
    /**
     * @notice Mint all remaining SOS balance as WrappedSOS
     */
    function mint() public {
        require(!emergencyFreeze, "Mint frozen");

        uint256 userSOS = sos.balanceOf(msg.sender);
        uint256 wrappedBalance = balanceOf[msg.sender];

        require(userSOS > wrappedBalance, "Nothing to mint");

        uint256 toMint = userSOS - wrappedBalance;

        balanceOf[msg.sender] += toMint;
        totalSupply += toMint;

        emit Transfer(address(0), msg.sender, toMint);
    }

    /**
     * @notice Mint up to `units` of WrappedSOS, capped by SOS balance
     */
    function bulkMint(uint256 units) external {
        require(!emergencyFreeze, "Mint frozen");
        require(units > 0, "Units must be > 0");

        uint256 userSOS = sos.balanceOf(msg.sender);
        uint256 wrappedBalance = balanceOf[msg.sender];

        uint256 available = userSOS - wrappedBalance;
        require(available > 0, "No units to mint");

        uint256 toMint = units > available ? available : units;

        balanceOf[msg.sender] += toMint;
        totalSupply += toMint;

        emit Transfer(address(0), msg.sender, toMint);
    }

    // ============ TRANSFER ============
    function transfer(address to, uint256 amount) external returns (bool) {
        require(to != address(0), "Zero address");
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");

        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;

        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address, uint256) external pure returns (bool) {
        revert("Allowances disabled");
    }

    function transferFrom(address, address, uint256) external pure returns (bool) {
        revert("Allowances disabled");
    }

    receive() external payable { revert("Cannot receive ETH"); }
    fallback() external payable { revert("Invalid call"); }
}
