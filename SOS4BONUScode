// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface ILineageBalance {
    function lineageBalanceOf(address account) external view returns (uint256);
    function lineageHash() external view returns (bytes32);
}

interface IMintable {
    function mint() external;
}

contract WrappedSOSV2 {
    string public name;
    string public symbol;
    uint8 public constant decimals = 18;

    ILineageBalance public immutable sos;       // underlying SOS
    bool public immutable emergencyFreeze;

    bytes32 public immutable expectedCodeHash;
    bytes32 public immutable expectedLineageHash;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    uint256 public totalSupply;

    // ===== Daily per-wallet limit =====
    uint256 public constant MAX_DAILY_MINT = 86400;
    mapping(address => uint256) public lastMintDay;
    mapping(address => uint256) public dailyMinted;

    // ===== EVENTS =====
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed minter, address indexed recipient, uint256 value, uint256 bonus);

    // ===== CONSTRUCTOR =====
    constructor(
        string memory name_,
        string memory symbol_,
        address sosAddress_,
        bool emergencyFreeze_,
        bytes32 expectedCodeHash_,
        bytes32 expectedLineageHash_
    ) {
        require(sosAddress_ != address(0), "SOS zero address");

        name = name_;
        symbol = symbol_;
        sos = ILineageBalance(sosAddress_);
        emergencyFreeze = emergencyFreeze_;
        expectedCodeHash = expectedCodeHash_;
        expectedLineageHash = expectedLineageHash_;

        if (expectedCodeHash_ != bytes32(0)) {
            require(
                keccak256(abi.encodePacked(address(sos).code)) == expectedCodeHash_,
                "SOS code hash mismatch"
            );
        }

        if (expectedLineageHash_ != bytes32(0)) {
            try sos.lineageHash() returns (bytes32 h) {
                require(h == expectedLineageHash_, "SOS lineage mismatch");
            } catch {
                revert("Failed to read SOS lineage");
            }
        }
    }

    // ===== ERC165 SUPPORT =====
    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {
        return
            interfaceId == type(IMintable).interfaceId ||
            interfaceId == 0x36372b07; // ERC20 transfer + approve + transferFrom
    }

    // ===== INTERNAL HELPER =====
    function _resetDailyMint(address user) internal {
        uint256 day = block.timestamp / 1 days;
        if (lastMintDay[user] < day) {
            lastMintDay[user] = day;
            dailyMinted[user] = 0;
        }
    }

    // ===== MINT WITH BONUS =====
    function mint() external {
        require(!emergencyFreeze, "Mint frozen");
        _resetDailyMint(msg.sender);

        uint256 userSOS;
        try sos.lineageBalanceOf(msg.sender) returns (uint256 total) {
            userSOS = total;
        } catch {
            userSOS = 0;
        }

        uint256 available = userSOS - balanceOf[msg.sender];
        require(available > 0, "Nothing to mint");

        // enforce daily limit
        uint256 remaining = MAX_DAILY_MINT - dailyMinted[msg.sender];
        uint256 toMint = available > remaining ? remaining : available;

        // dynamic bonus (lineage aware)
        uint256 bonus = _calculateBonus(msg.sender, toMint);

        balanceOf[msg.sender] += toMint + bonus;
        totalSupply += toMint + bonus;
        dailyMinted[msg.sender] += toMint;

        emit Transfer(address(0), msg.sender, toMint + bonus);
        emit Mint(msg.sender, msg.sender, toMint, bonus);
    }

    function bulkMint(uint256 units) external {
        require(!emergencyFreeze, "Mint frozen");
        require(units > 0, "Units must be > 0");

        _resetDailyMint(msg.sender);

        uint256 userSOS;
        try sos.lineageBalanceOf(msg.sender) returns (uint256 total) {
            userSOS = total;
        } catch {
            userSOS = 0;
        }

        uint256 available = userSOS - balanceOf[msg.sender];
        require(available > 0, "No units to mint");

        uint256 remaining = MAX_DAILY_MINT - dailyMinted[msg.sender];
        uint256 toMint = units > available ? available : units;
        toMint = toMint > remaining ? remaining : toMint;

        uint256 bonus = _calculateBonus(msg.sender, toMint);

        balanceOf[msg.sender] += toMint + bonus;
        totalSupply += toMint + bonus;
        dailyMinted[msg.sender] += toMint;

        emit Transfer(address(0), msg.sender, toMint + bonus);
        emit Mint(msg.sender, msg.sender, toMint, bonus);
    }

    // ===== DYNAMIC BONUS CALCULATION =====
    function _calculateBonus(address user, uint256 commit) internal view returns (uint256) {
        uint256 totalLineage;
        try sos.lineageBalanceOf(user) returns (uint256 total) {
            totalLineage = total;
        } catch {
            totalLineage = 0;
        }

        if (totalLineage == 0) return 0;

        uint256 fraction = (commit * 1e18) / totalLineage;

        // bonus tiers: <40% = 15%, 50% = 10%, >60% = 5%
        if (fraction < 0.4e18) return (commit * 15) / 100;
        if (fraction >= 0.4e18 && fraction < 0.6e18) return (commit * 10) / 100;
        return (commit * 5) / 100;
    }

    // ===== ERC20 FUNCTIONS =====
    function transfer(address to, uint256 amount) external returns (bool) {
        require(to != address(0), "Zero address");
        uint256 senderBalance = balanceOf[msg.sender];
        require(senderBalance >= amount, "Insufficient balance");

        balanceOf[msg.sender] = senderBalance - amount;
        balanceOf[to] += amount;

        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        require(spender != address(0), "Zero address");
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(to != address(0), "Zero address");
        uint256 senderAllowance = allowance[from][msg.sender];
        uint256 fromBalance = balanceOf[from];
        require(senderAllowance >= amount, "Allowance exceeded");
        require(fromBalance >= amount, "Insufficient balance");

        allowance[from][msg.sender] = senderAllowance - amount;
        balanceOf[from] = fromBalance - amount;
        balanceOf[to] += amount;

        emit Transfer(from, to, amount);
        return true;
    }

    // ===== REJECT ETH =====
    receive() external payable { revert("Cannot receive ETH"); }
    fallback() external payable { revert("Invalid call"); }
}
