// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

contract SOS is IERC165 {

    // ============ EVENTS ============
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Mint(address indexed minter, address indexed recipient, uint256 value);

    // ============ TOKEN STORAGE ============
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    string public name;
    string public symbol;
    uint8 public constant decimals = 18;

    // ============ LINEAGE METADATA ============
    address public immutable controller;           
    address public immutable parentContract;
    bytes32 public immutable parentCodeHash;
    bytes32 public immutable lineageHash;
    address public immutable previousController;
    bool public immutable emergencyPatch;
    bytes32 public immutable enforcedCodeHash;

    uint256 public constant ATOMIC_MINT = 1;

    // ============ INTERFACES ============
    bytes4 private constant _INTERFACE_ID_MINTABLE = type(IERC165).interfaceId; // example, can define your own

    constructor(
        string memory name_,
        string memory symbol_,
        address parentContract_,
        address previousController_,
        bool emergencyPatch_,
        bytes32 enforcedCodeHash_
    ) {
        name = name_;
        symbol = symbol_;
        controller = msg.sender;
        parentContract = parentContract_;
        previousController = previousController_;
        emergencyPatch = emergencyPatch_;
        enforcedCodeHash = enforcedCodeHash_;

        bytes32 parentLineageHash;

        if (parentContract_ == address(0)) {
            parentCodeHash = bytes32(0);
            parentLineageHash = bytes32(0);
        } else {
            require(parentContract_.code.length > 0, "Parent not contract");
            parentCodeHash = parentContract_.codehash;

            if (!emergencyPatch_ && enforcedCodeHash_ != bytes32(0)) {
                require(parentCodeHash == enforcedCodeHash_, "Parent code hash invalid");
            }

            try SOS(parentContract_).lineageHash() returns (bytes32 h) {
                parentLineageHash = h;
            } catch {
                revert("Invalid parent SOS");
            }
        }

        lineageHash = keccak256(
            abi.encodePacked(parentLineageHash, address(this), block.chainid, emergencyPatch_)
        );
    }

    // ============ MINT ============
    function mint(address recipient) external {
        require(recipient != msg.sender, "Cannot mint for yourself");
        require(recipient != address(0), "Zero address");

        balanceOf[recipient] += ATOMIC_MINT;
        totalSupply += ATOMIC_MINT;

        emit Transfer(address(0), recipient, ATOMIC_MINT);
        emit Mint(msg.sender, recipient, ATOMIC_MINT);
    }

    // ============ DISABLE TRANSFERS ============
    function transfer(address, uint256) external pure returns (bool) { revert("Transfers disabled forever"); }
    function approve(address, uint256) external pure returns (bool) { revert("Allowances disabled forever"); }
    function transferFrom(address, address, uint256) external pure returns (bool) { revert("Transfers disabled forever"); }

    // ============ REJECT ETH ============
    receive() external payable { revert("Cannot receive ETH"); }
    fallback() external payable { revert("Invalid call"); }

    // ============ EIP-165 ============
    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {
        // Example: returns true for Mint event interface
        return interfaceId == type(IERC165).interfaceId;
    }
}
