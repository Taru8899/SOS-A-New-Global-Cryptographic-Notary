// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract SOS is ERC20 {
    /// @notice Controller (deployer) of THIS SOS instance
    address public immutable controller;
    
    /// @notice Controller of the PREVIOUS SOS instance (lineage)
    address public immutable previousController;
    
    /// @notice Atomic mint unit (1 wei of SOS)
    uint256 public constant ATOMIC_MINT = 1;

    /// @notice Struct to record atomic mint metadata
    struct MintRecord {
        uint256 amount;     // always 1 atomic unit
        uint256 chainId;    // chain used for minting
        uint256 gasPaid;    // gas spent (in wei)
        uint256 timestamp;  // block timestamp of mint
    }

    /// @notice Mapping from minter to their mint history
    mapping(address => MintRecord[]) public mintHistory;

    constructor(
        string memory name_,
        string memory symbol_,
        address previousController_
    ) ERC20(name_, symbol_) {
        controller = msg.sender;
        previousController = previousController_;
    }

    /**
     * @notice Mint exactly 1 atomic unit to another address
     * @dev Cannot mint to yourself; stores mint metadata
     * @param recipient Address to mint to
     * @param chainId_ Chain ID used for minting (for off-chain verification)
     * @param gasPaid_ Gas spent on minting (for off-chain verification)
     */
    function mint(address recipient, uint256 chainId_, uint256 gasPaid_) external {
        require(recipient != msg.sender, "Cannot mint for yourself");
        _mint(recipient, ATOMIC_MINT);

        // Store mint metadata
        MintRecord memory record = MintRecord({
            amount: ATOMIC_MINT,
            chainId: chainId_,
            gasPaid: gasPaid_,
            timestamp: block.timestamp
        });
        mintHistory[recipient].push(record);
    }

    // ============ NO BURN ============
    // Prevent transfer to zero address (burn)
    function _update(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // Allow only minting (from == address(0))
        require(from == address(0), "Transfers disabled forever");
        
        // Explicitly prevent burn
        require(to != address(0), "Burn disabled forever");
        
        super._update(from, to, amount);
    }

    // ============ NO TRANSFERS (NO SWAP, NO DEX) ============
    function transfer(address, uint256) public pure override returns (bool) {
        revert("Transfers, swaps, or LP interactions disabled forever");
    }
    
    function transferFrom(address, address, uint256) public pure override returns (bool) {
        revert("Transfers, swaps, or LP interactions disabled forever");
    }

    // ============ NO APPROVE ============
    function approve(address, uint256) public pure override returns (bool) {
        revert("Allowances disabled forever");
    }
    
    function increaseAllowance(address, uint256) public pure returns (bool) {
        revert("Allowances disabled forever");
    }
    
    function decreaseAllowance(address, uint256) public pure returns (bool) {
        revert("Allowances disabled forever");
    }

    // ============ NO SELFDESTRUCT ============
    // No selfdestruct function at all
    
    // ============ NO PROXY PATTERNS ============
    // No initializer function (UUPS/Transparent proxy patterns)
    // No storage gaps for upgradeability
    // No delegatecall functionality

    // ============ REJECT ALL CALLS EXCEPT MINT ============
    fallback() external payable {
        revert("No calls allowed except mint");
    }
    
    // ============ REJECT ETH ============
    receive() external payable {
        revert("Cannot receive ETH");
    }

    // ============ VIEW HELPERS ============
    /// @notice Returns number of mints for an address
    function mintCount(address account) external view returns (uint256) {
        return mintHistory[account].length;
    }

    /// @notice Returns specific mint record
    function getMint(address account, uint256 index) external view returns (MintRecord memory) {
        require(index < mintHistory[account].length, "Index out of bounds");
        return mintHistory[account][index];
    }
}
